Improve Heading Detection by Identifying and Filtering False Positives in Extracted PDF Headings**

---

#### üìÑ **Context**

You're given the following components from an Adobe Hackathon Round 1A heading extraction pipeline:

* A trained ML model that predicts whether a text block in a PDF is a heading.
* A JSON output (`outline`) which lists predicted headings.
* A Python script (`generate_json_output.py`) that extracts text blocks and features (font size, position, POS tags, etc.), runs the model, and outputs the JSON.
* A PDF document which includes academic-style report content.

The model performs reasonably well, but **generates excessive false positives**. Your task is to **act as a refining agent** that improves heading detection accuracy via **post-processing logic** that corrects these mistakes.

---

#### ‚ùóÔ∏èProblem Statement

The current ML model, despite being trained with good features (TF-IDF, font, bounding box, POS, etc.), marks many **non-heading** text blocks as headings. These false positives clutter the output and confuse downstream systems.

##### Examples of Incorrect Headings Output (from the JSON):

These were wrongly marked as H1:

* `"Junaid Ahmad"`
* `"Registration : 12315906"`
* `"Lovely Professional University"`
* `"Phagwara"`
* `"Bcrypt.js"`
* `"These"`
* `"Initially,"`
* `"The system's containerized infrastructure, powered by Docker"`
* `"automation, and Oracle VPS as the hosting environment. This"`

These are not headings but **names, statements, or fragments**. They:

* Appear mid-page or mid-column
* Have no semantic indication of section hierarchy
* Include verbs, full stops, and normal sentence syntax
* Lack structural separation or font distinction

---

### üéØ Your Goal

Design and implement an **intelligent, rule-based post-filtering module** (class or function) to **reduce false positives** without hurting true positive rate.

This system will be used **after the model predicts headings** and before the final JSON output.

---

### üîç Your Plan (Agent Mode Instructions)

1. **Load the predicted headings DataFrame**. Each row includes:

   * `text`, `font_size`, `x0`, `y0`, `x1`, `y1`, `page_num`
   * Model outputs: `is_heading_pred`, `heading_confidence`
   * Feature columns like `noun_ratio`, `verb_ratio`, `word_count`, `char_count`, `starts_with_capital`, `center_aligned`

2. **Filter out false positives** using rules below.

3. **Output a refined DataFrame** of valid headings, and write a cleaner JSON (`title`, `outline`) conforming to schema:

   ```json
   {
     "title": "Title of PDF",
     "outline": [
       {"level": "H1", "text": "Heading Text", "page": 1},
       ...
     ]
   }
   ```

---

### ‚úÖ Filtering Rules to Apply (Implement as Logic or Decision Tree)

#### üìå **Rule 1: Reject sentence-like structures**

* If `text` ends with a full stop `"."`, it's likely a sentence.
* If `word_count > 12` or `char_count > 120`, it's too long for a heading.

```python
if text.endswith(".") or word_count > 12 or char_count > 120:
    reject()
```

#### üìå **Rule 2: Reject identity blocks or names**

* Reject if the text contains person names or university/registration-like patterns:

```python
if any(word in text.lower() for word in ["university", "registration", "b.tech", "name", "phagwara"]):
    reject()
```

#### üìå **Rule 3: POS-based filter**

* Use POS tags to reject overly verb-heavy lines

```python
if verb_ratio > 0.3 and noun_ratio < 0.2:
    reject()
```

#### üìå **Rule 4: Must start with capital or number**

* Headings typically start with uppercase or numerals like `I.` or `1.`

```python
if not text[0].isupper() and not text[0].isdigit():
    reject()
```

#### üìå **Rule 5: Must not be fragments**

* Avoid single disconnected words (e.g., `"These"`, `"Initially"`, `"Dockerfile"`)

```python
if word_count <= 2 and not has_common_heading_words:
    reject()
```

#### üìå **Rule 6: Use font and layout**

* Disqualify headings if:

  * Font size is **below 50th percentile**
  * Not **center aligned** (for H1)
  * Not on **top 30% of the page**

```python
if font_size < median_font_size and center_aligned == 0 and y_position_norm > 0.3:
    reject()
```

---

### üß† Optional Bonus: Intelligent Heuristic Features

You can compute soft filters using additional logic:

* Use `starts_with_capital` and `title_case` together to strengthen prediction.
* If a line has **bold markers**, treat as more likely to be a heading.
* If `has_proper_nouns > 0` and `minimal_verbs == 1`, allow.

---

### üì¶ Deliverables (Agent Output)

* A Python class or method: `IntelligentFilter.apply(df)`
* Takes a DataFrame of predicted blocks, returns a filtered DataFrame
* Optional: Log `rejected_reason` for each rejected line (for debug mode)
* Reuse existing features from `generate_json_output.py` where needed

---

### üß† Your Capability

You are allowed to:

* Add new rules or combine features logically
* Refactor the DataFrame or JSON schema if needed
* Create a debugging report (optional): showing true positives, false positives

---

### ‚úçÔ∏è Signature

This refinement will directly reduce **false positives in heading detection** and help generate accurate structured outlines from long academic or technical documents. Your job is to be **surgical and semantic**, not just syntactic.

---
